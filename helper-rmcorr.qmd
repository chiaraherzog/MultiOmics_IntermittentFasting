---
title: "Repeated measures correlation for multi-omic integration"
format:
  html:
    toc: true
    code-fold: true
    code-overflow: wrap
    code-tools: true
---

```{r setup, include=F}
knitr::opts_chunk$set(echo = T, message = F, warning = F, eval = F)
```


```{r libs}
library(dplyr)
library(here)
library(rmcorr)
library(ggplot2)
library(MultiAssayExperiment)
here::i_am("helper-rmcorr.qmd")
```

This script is used to generate repeated measures correlation (rmcorr) on features, using both normalized absolute data and normalized change data. The outputs are saved under `out/rmcorr.Rdata` and `out/rmcorr_change.Rdata`.

# 1. Absolute normalized data

## Load data

Normalized data are loaded. We are focusing on a few informative and relevant features (e.g., families rather than ASVs).

```{r loaddata.all, eval = F}
# load in data
load("data/data_normalized.Rdata")

load("src/vars.Rdata")

vars <- vars |> dplyr::filter(assay %in% c('Blood haemogram',
            'Body composition',
            'Skin histology and transepidermal water loss assay',
            'Functional sports exam',
            'Vascular and body sonography',
            'Flow cytometry: T cell staining',
            'Flow cytometry: white blood cell staining',
            'Flow cytometry: stimulated T cells',
            'Flow cytometry: unstimulated T cells',
            'Urine nuclear magnetic resonance: normalized',
            'Saliva nuclear magnetic resonance: normalized',
            'Composite methylation scores: blood',
            'Composite methylation scores: buccal',
            'Composite methylation scores: cervical',
            'Stool microbiome: families',
            'Saliva microbiome: families',
            'Immune age: general',
            'Vascular and body sonography')) |> 
  dplyr::group_by(assay) |> 
  dplyr::summarise(features = list(x), .groups = 'drop') |> tibble::deframe()

# Get data in long format
df <- as.data.frame(longForm(subsetByAssay(data, vars),
                               colData = c('subjectId', 'interventionId', 'visitId'))) 

# Filtering:

## a) Filter I/K intervention and M0-M6 only
df <- df |> 
  dplyr::filter(interventionId != 'S' & !visitId %in% c('M12', 'M18')) |> 
  dplyr::mutate(visitId = as.numeric(gsub("M", "", visitId))) |> 
  dplyr::select(primary, rowname, visitId, assay, value, subjectId) 

# b) For microbiome, keep only those that are non-0/non-NA in more than 50% of individuals/timepoints
fam_count <- df |> 
  dplyr::filter(grepl("families", assay)) |> 
  dplyr::group_by(assay, rowname) |> 
  dplyr::reframe(zeros = (sum(value == 0, na.rm = T)+sum(is.na(value)))/n()) |> 
  dplyr::filter(zeros < 0.5)

df <- df |> dplyr::filter(!grepl("families", assay) | (grepl("families", assay) & rowname %in% fam_count$rowname))

# Formating: Now we can pivot data to wider, concatenating assay and rowname for unique variables
dat <- df |> 
  dplyr::mutate(name = paste0(assay, '_', rowname)) |> 
  dplyr::select(-rowname) |> 
  tidyr::pivot_wider(names_from = 'name',
                     values_from = 'value',
                     id_cols = c('primary', 'subjectId', 'visitId'))

dat <- dat |> 
  dplyr::select(where(~!all(is.na(.x)))) 
save(dat, file = here("out/plot_rmcorr_examples.Rdata"))
rm(list=ls());gc()
```

## Run rmcorr

Once the data have been prepared, we can now run rmcorr:

* Variables are unique columns to be included
* the subjectId indicates individuals for repeats

```{r}
load(here("out/plot_rmcorr_examples.Rdata"))
vars <- colnames(dat)[!colnames(dat) %in% c('primary', 'subjectId')]

dat$subjectId <- as.factor(dat$subjectId)
measures1 <- vars
measures2 <- vars

pairs <- tidyr::crossing(measure1 = measures1, measure2 = measures2)

run_rmc <- function(m1, m2){
  
  tmp <- rmcorr(participant = subjectId,
                measure1    = m1,
                measure2    = m2, 
                dataset = dat)
  tibble(
    measure1 = m1, measure2 = m2,
    r = tmp$r, p = tmp$p, df = tmp$df,
    ci_lo = tmp$CI[1], ci_hi = tmp$CI[2], ci_lvl = tmp$CI.level
  )
}

# progress = nice console bar/spinner; no pb$tick() needed
res <- purrr::pmap_dfr(
  pairs,
  ~ run_rmc(..1, ..2),
  .progress = "Running repeated-measures correlations"
)

res <- res |>
  dplyr::group_by(measure1) |> 
  dplyr::mutate(padj = p.adjust(p, method = 'fdr')) |> 
  dplyr::ungroup()

save(res, file = here('out/rmcorr.Rdata'))
# save(rmcorr, file = here('out/rmcorr.Rdata'))
```

## Initial exploration

```{r DT.all, eval = F}
load(here('out/rmcorr.Rdata'))
rmcorr |> 
  dplyr::filter(assay1 != assay2) |> 
  dplyr::select(-c(assay1, assay2, df)) |> 
  dplyr::filter(p.vals < 0.05) |> 
  dplyr::arrange(p.vals) |> 
  DT::datatable()
```

* p Value histogram

```{r hist.all, fig.width = 3.5, fig.height = 3.5, eval = F}
rmcorr |> 
  ggplot(aes(x = p.vals)) +
  geom_histogram(bins = 200) +
  theme_bw()
```

```{r}
rm(list=ls());gc()
```

# 2. Normalized change data

## Load data

Normalized data are loaded. We are focusing on a few informative and relevant features (e.g., families rather than ASVs).

```{r load.data.change, eval = F}
# load in data
load("data/data_normalized_baseline.Rdata")

load("src/vars.Rdata")

vars <- vars |> dplyr::filter(assay %in% c('Blood haemogram',
            'Body composition',
            'Skin histology and transepidermal water loss assay',
            'Functional sports exam',
            'Vascular and body sonography',
            'Flow cytometry: T cell staining',
            'Flow cytometry: white blood cell staining',
            'Flow cytometry: stimulated T cells',
            'Flow cytometry: unstimulated T cells',
            'Urine nuclear magnetic resonance: normalized',
            'Saliva nuclear magnetic resonance: normalized',
            'Composite methylation scores: blood',
            'Composite methylation scores: buccal',
            'Composite methylation scores: cervical',
            'Stool microbiome: families',
            'Saliva microbiome: families',
            'Immune age: general',
            'Vascular and body sonography')) |> 
  dplyr::group_by(assay) |> 
  dplyr::summarise(features = list(x), .groups = 'drop') |> tibble::deframe()

# Get data in long format
df <- as.data.frame(longForm(subsetByAssay(data, vars),
                               colData = c('subjectId', 'interventionId', 'visitId'))) 

# Filtering:

## a) Filter I/K intervention and M0-M6 only
df <- df |> 
  dplyr::filter(interventionId != 'S' & !visitId %in% c('M12', 'M18')) |> 
  dplyr::mutate(visitId = as.numeric(gsub("M", "", visitId))) |> 
  dplyr::select(primary, rowname, visitId, assay, value, subjectId) 

# b) For microbiome, keep only those that are non-0/non-NA in more than 50% of individuals/timepoints
fam_count <- df |> 
  dplyr::filter(grepl("families", assay)) |> 
  dplyr::group_by(assay, rowname) |> 
  dplyr::reframe(zeros = (sum(value == 0, na.rm = T)+sum(is.na(value)))/n()) |> 
  dplyr::filter(zeros < 0.5)

df <- df |> dplyr::filter(!grepl("families", assay) | (grepl("families", assay) & rowname %in% fam_count$rowname))

# Formating: Now we can pivot data to wider, concatenating assay and rowname for unique variables
dat <- df |> 
  dplyr::mutate(name = paste0(assay, '_', rowname)) |> 
  dplyr::select(-rowname) |> 
  tidyr::pivot_wider(names_from = 'name',
                     values_from = 'value',
                     id_cols = c('primary', 'subjectId', 'visitId'))

dat <- dat |> 
  dplyr::select(where(~!all(is.na(.x)))) 
save(dat, file = here("out/plot_rmcorr_examples_change.Rdata"))
rm(list=ls());gc()
```


## Run rmcorr

Once the data have been prepared, we can now run rmcorr:

* Variables are unique columns to be included
* the subjectId indicates individuals for repeats

```{r}
# run rmcorr over same variables as the main rmcorr (minus log)
load(here("out/plot_rmcorr_examples_change.Rdata"))
vars <- colnames(dat)[!colnames(dat) %in% c('primary', 'subjectId')]

dat$subjectId <- as.factor(dat$subjectId)
measures1 <- vars
measures2 <- vars

pairs <- tidyr::crossing(measure1 = measures1, measure2 = measures2)

run_rmc <- function(m1, m2){
  
  tmp <- rmcorr(participant = subjectId,
                measure1    = m1,
                measure2    = m2, 
                dataset = dat)
  tibble(
    measure1 = m1, measure2 = m2,
    r = tmp$r, p = tmp$p, df = tmp$df,
    ci_lo = tmp$CI[1], ci_hi = tmp$CI[2], ci_lvl = tmp$CI.level
  )
}

# progress = nice console bar/spinner; no pb$tick() needed
res <- purrr::pmap_dfr(
  pairs,
  ~ run_rmc(..1, ..2),
  .progress = "Running repeated-measures correlations"
)

res_change <- res |>
  dplyr::group_by(measure1) |> 
  dplyr::mutate(padj = p.adjust(p, method = 'fdr')) |> 
  dplyr::ungroup()

save(res_change, file = here('out/rmcorr_change.Rdata'))

# save(rmcorr, file = here('out/rmcorr_change.Rdata'))
# 
# rmcorr_change_matrix <- out$matrix
# save(rmcorr_change, file = here('out/rmcorr_change.Rdata'))
rm(list=ls());gc()
```


# Formatting for easier plotting

```{r}
load(here('out/rmcorr_change.Rdata'))
rmcorr_change <- res_change

labelRMCorr <- function(obj){
  # Load and p adjust
  tmp <- rmcorr_change |> 
    dplyr::filter(!grepl("ImmAge_gen_adj", measure1) | !grepl("ImmAge_gen_adj", measure2)) |> 
    dplyr::filter(measure1 != measure2) |> 
    dplyr::group_by(measure1) |> 
    dplyr::mutate(padj_v2 = p.adjust(p, method = 'fdr')) |> 
    dplyr::ungroup() |> 
    tidyr::separate(measure1, sep = "_", into = c("assay1", "measure1"), remove = T,
                    extra = 'merge') |> 
    tidyr::separate(measure2, sep = "_", into = c("assay2", "measure2"), remove = T,
                    extra = 'merge')

  # unique variables
  tmp_unique <- tmp |> 
    dplyr::rowwise() |> 
      mutate(
        # Create canonical ordering: paste the "smaller" first
        pair1 = paste(assay1, measure1, sep = "|"),
        pair2 = paste(assay2, measure2, sep = "|"),
        key   = paste(sort(c(pair1, pair2)), collapse = "___")  # order-independent ID
      ) |> 
      ungroup() |> 
      distinct(key, .keep_all = TRUE) |> 
      dplyr::select(-pair1, -pair2, -key) 
  
  # Append labels
  load("src/vars.Rdata")
  vars <- vars |> 
    dplyr::mutate(assay_lab = ifelse(!is.na(assay2), assay2, assay))
  
  tmp_unique_lab1 <- tmp_unique |> 
    dplyr::left_join(dplyr::select(vars, assay, x, label, assay_lab),
                     by = c("assay1" = 'assay',
                            "measure1" = 'x')) |> 
    dplyr::rename(label1 = label,
                  assay_lab1 = assay_lab) |> 
    dplyr::left_join(dplyr::select(vars, assay, x, label, assay_lab),
                     by = c("assay2" = 'assay',
                            "measure2" = 'x')) |> 
    dplyr::rename(label2 = label,
                  assay_lab2 = assay_lab)

  
  out <- tmp_unique_lab1 |> 
    dplyr::select(assay_lab1, label1, 
                  assay_lab2, label2, r:padj_v2,
                  assay1:measure2)
}

rmcorr_change_cleaned <- labelRMCorr(rmcorr_change)
save(rmcorr_change_cleaned, file = 'out/rmcorr_change_cleaned.Rdata')


load(here('out/rmcorr.Rdata'))
rmcorr <- res

rmcorr_cleaned <- labelRMCorr(rmcorr)
save(rmcorr_cleaned, file = 'out/rmcorr_cleaned.Rdata')


# Additional preprocessing steps: consistent change.
load('out/rmcorr_change_cleaned.Rdata')
load('out/rmcorr_cleaned.Rdata')

# Consistent change
corr <- rmcorr_cleaned |> 
    dplyr::left_join(rmcorr_change_cleaned,
                     by = c('measure1', 'measure2', 'assay1', 'assay2',
                            'label1', 'assay_lab1', 'label2', 'assay_lab2'),
                     suffix = c('', '.change')) |> 
    dplyr::filter(sign(r) == sign(r.change)) |> 
  dplyr::filter(measure1 != 'ImmAge_gen_adj' & measure2 != 'ImmAge_gen_adj') |> 
    
    # Additional filtering: Exclude visitId
    dplyr::filter(!assay1 %in% c('visitId') & !assay2 %in% c('visitId')) |> 
  
  dplyr::filter(assay_lab1 != assay_lab2) |> 
  
  dplyr::filter(!(grepl("Immune age", assay_lab1) & grepl("cytometry", assay_lab2)) &
                  !(grepl("Immune age", assay_lab2) & grepl("cytometry", assay_lab2))) |> 
  
  # remove ASVs
  dplyr::filter(!grepl("ASV", measure1) | !grepl("ASV", measure2))

save(corr, file = 'out/rmcorr_full.Rdata')

```


```{r extract, eval = F}
knitr::purl("helper-rmcorr.qmd",
            output = 'helper-rmcorr.R')
```